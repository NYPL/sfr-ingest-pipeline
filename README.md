# SFR Cover Search

This function provides a lookup service for cover images for instance records that do not have an associated cover from the provider (Project Gutenberg or HathiTrust). The third-party services that are queried for covers are OpenLibrary, Google Books and Content Cafe.

It queries the SFR database for `instance` records which lack a link for a cover that have been updated in the defined range.

## Requirements

- Python 3.6+ (written with Python 3.7)
- OpenLibrary API Database (described below)

## Dependencies

- requests
- sfrCore

## OpenLibrary Integration

The OpenLibrary API makes a "covers" endpoint available [here](https://openlibrary.org/dev/docs/api/covers). This API provides access to a valuable set of covers accessible by a range of identifiers, making it valuable to this project. However it is heavily throttled to 100 requests/5 minutes, which is too strict for this project. However, its functionality can be replicated through use of a simple SQL database that allows for look ups of OpenLibrary cover identifiers by ISBN, OCLC, etc.

To provide this we have replicated the OpenLibrary service with a data dump of their covers that has been provided through their site. This is hosted on AWS RDS and consists of a two table SQL database. The `openLibraryFetcher` class utilizes this to retrieve covers. To replicate this functionality contact the authors of this function for either a dump of the database or information on how to build a similar database for its use. Alternatively the OpenLibrary fetcher can be excluded from this by removing from the tuple of options in the `CoverManager` class.

## Development

### Installation

1. Create a virtualenv (varies depending on your shell) and activate it
2. Install dependencies via `pip install -r requirements.txt`
3. Install dev dependencies via `pip install -r dev-requirements.txt`

### Setup Environment Variables

The following environment variables should be set on a per-environment basis.

- LOG_LEVEL: One of `debug|info|warning|error`
- UPDATE_PERIOD: Period, in seconds, to check for updated instance records
- CONTENT_CAFE_USER: KMS-encoded username for the ContentCafe API
- CONTENT_CAFE_PSWD: KMS-encoded password for the ContentCafe API
- GOOGLE_BOOKS_KEY: KMS-encoded Google API key with permissions for the Google Books API
- DB_HOST: KMS-encoded key for the main SFR db host
- DB_NAME: KMS-encoded key for the main SFR db name
- DB_PORT: Port for the main SFR db
- DB_USER: KMS-encoded key for the main SFR db user
- DB_PSWD: KMS-encoded key for the main SFR db user's password
- DB_OL_NAME: KMS-encoded kye for the OpenLibrary API db name

### A note on Encoded environment variables

Many of the above environment variables should be added as AWS KMS encoded values. They are sensitive, granting access to databases or an NYPL account to a restricted API. These can be generated by using the AWS CLI tool. The values in this repository contain the defaults for the SFR project. If you are using this service for a different project, or a clone of the SFR project, ensure that they are replaced with the appropriate settings for you work

### Develop Locally

To run this function locally run `make local-run` which will execute the Lambda. Use caution with this command, as configured it will place any fetched covers in the ingest stream for SFR, with potentially unintended side effects

### Deploy the Lambda

To deploy the Lambda be sure that you have completed the setup steps above and have tested your lambda, as well as configured any necessary environment variables.

To run the deployment run `make deploy ENV=[environment]` where environment is one of development/qa/production

**Deploy via TravisCI**

This function is configured to automatically deploy via integration with travisCI. View the `.travis.yml` file for details of this integration

## Tests

`pytest` is currently used to provide test coverage and can be run with `make test`

Coverage is used to measure test coverage and a report can be seen by running `make coverage-report`

## Linting

Linting is provided via Flake8 and can be run with `make lint`
